diff --git a/qtbase/mkspecs/common/msvc-desktop.conf b/qtbase/mkspecs/common/msvc-desktop.conf
index e638af6..e44ee5e 100644
--- a/qtbase/mkspecs/common/msvc-desktop.conf
+++ b/qtbase/mkspecs/common/msvc-desktop.conf
@@ -28,9 +28,9 @@ QMAKE_YACCFLAGS         = -d
 QMAKE_CFLAGS            = -nologo -Zc:wchar_t
 QMAKE_CFLAGS_WARN_ON    = -W3
 QMAKE_CFLAGS_WARN_OFF   = -W0
-QMAKE_CFLAGS_RELEASE    = -O2 -MD
-QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += -O2 -MD -Zi
-QMAKE_CFLAGS_DEBUG      = -Zi -MDd
+QMAKE_CFLAGS_RELEASE    = -O2 -MT
+QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += -O2 -MT -Zi
+QMAKE_CFLAGS_DEBUG      = -Zi -MTd
 QMAKE_CFLAGS_YACC       =
 QMAKE_CFLAGS_LTCG       = -GL
 QMAKE_CFLAGS_SSE2       = -arch:SSE2
diff --git a/qtbase/qmake/generators/mac/pbuilder_pbx.cpp b/qtbase/qmake/generators/mac/pbuilder_pbx.cpp
index 81bb068..a0fe016 100644
--- a/qtbase/qmake/generators/mac/pbuilder_pbx.cpp
+++ b/qtbase/qmake/generators/mac/pbuilder_pbx.cpp
@@ -1500,11 +1500,15 @@ ProjectBuilderMakefileGenerator::writeMakeParts(QTextStream &t)
                             plist_in_text.replace("@TYPEINFO@",
                                 (project->isEmpty("QMAKE_PKGINFO_TYPEINFO")
                                     ? QString::fromLatin1("????") : project->first("QMAKE_PKGINFO_TYPEINFO").left(4).toQString()));
-                            QFile plist_out_file(Option::output_dir + "/Info.plist");
-                            if (plist_out_file.open(QIODevice::WriteOnly | QIODevice::Text)) {
+							QString plist_dir;
+							if (!project->isEmpty("PLIST_DIR"))
+								plist_dir = project->first("PLIST_DIR").toQString();
+							QString plist_in_filename = QFileInfo(plist_in_file).fileName();
+							QFile plist_out_file(Option::output_dir + "/" + plist_dir + plist_in_filename);
+							if (plist_out_file.open(QIODevice::WriteOnly | QIODevice::Text)) {
                                 QTextStream plist_out(&plist_out_file);
                                 plist_out << plist_in_text;
-                                t << "\t\t\t\t" << writeSettings("INFOPLIST_FILE", "Info.plist") << ";\n";
+								t << "\t\t\t\t" << writeSettings("INFOPLIST_FILE", fixForOutput(plist_dir + plist_in_filename)) << ";\n";
                             }
                         }
                     }
diff --git a/qtbase/qmake/generators/makefile.cpp b/qtbase/qmake/generators/makefile.cpp
index 4a03faf..2c18c48 100644
--- a/qtbase/qmake/generators/makefile.cpp
+++ b/qtbase/qmake/generators/makefile.cpp
@@ -167,7 +167,7 @@ MakefileGenerator::initOutPaths()
         v["PRECOMPILED_DIR"] = v["OBJECTS_DIR"];
     static const char * const dirs[] = { "OBJECTS_DIR", "DESTDIR",
                                          "SUBLIBS_DIR", "DLLDESTDIR",
-                                         "PRECOMPILED_DIR", 0 };
+										 "PRECOMPILED_DIR", "PLIST_DIR", 0 };
     for (int x = 0; dirs[x]; x++) {
         const ProKey dkey(dirs[x]);
         if (v[dkey].isEmpty())
diff --git a/qtbase/src/3rdparty/pcre/pcre16_valid_utf16.c b/qtbase/src/3rdparty/pcre/pcre16_valid_utf16.c
index 0907653..96f6e19 100644
--- a/qtbase/src/3rdparty/pcre/pcre16_valid_utf16.c
+++ b/qtbase/src/3rdparty/pcre/pcre16_valid_utf16.c
@@ -101,7 +101,7 @@ for (p = string; length-- > 0; p++)
     {
     /* Normal UTF-16 code point. Neither high nor low surrogate. */
     }
-  else if ((c & 0x0400) == 0)
+  else if ((c & 0xfc00) == 0xd800)
     {
     /* High surrogate. Must be a followed by a low surrogate. */
     if (length == 0)
diff --git a/qtbase/src/corelib/kernel/qobjectdefs.h b/qtbase/src/corelib/kernel/qobjectdefs.h
index 4d01264..fd3854f 100644
--- a/qtbase/src/corelib/kernel/qobjectdefs.h
+++ b/qtbase/src/corelib/kernel/qobjectdefs.h
@@ -142,7 +142,7 @@ inline void qYouForgotTheQ_OBJECT_Macro(T1, T2) {}
 # define Q_DECL_HIDDEN_STATIC_METACALL Q_DECL_HIDDEN
 #endif
 
-#if defined(Q_CC_CLANG) && Q_CC_CLANG >= 306
+#if defined(Q_CC_CLANG) && Q_CC_CLANG >= 306 && false
 #  define Q_OBJECT_NO_OVERRIDE_WARNING      QT_WARNING_DISABLE_CLANG("-Winconsistent-missing-override")
 #else
 #  define Q_OBJECT_NO_OVERRIDE_WARNING
diff --git a/qtbase/src/corelib/tools/qunicodetables.cpp b/qtbase/src/corelib/tools/qunicodetables.cpp
index 73dce81..76c6933 100644
--- a/qtbase/src/corelib/tools/qunicodetables.cpp
+++ b/qtbase/src/corelib/tools/qunicodetables.cpp
@@ -5839,7 +5839,7 @@ static const Properties uc_properties[] = {
     { 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 7, 4, 4, 21, 11 },
     { 0, 17, 230, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 4, 4, 21, 11 },
     { 18, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 85, 0, 8, 8, 12, 11 },
-    { 25, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 17, 2 },
+    { 25, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 17, 11 },
     { 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 14, 9, 11, 11 },
     { 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 14, 9, 11, 11 },
     { 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 14, 9, 11, 11 },
diff --git a/qtbase/src/gui/image/qbmphandler.cpp b/qtbase/src/gui/image/qbmphandler.cpp
index f124ced..eb78a13 100644
--- a/qtbase/src/gui/image/qbmphandler.cpp
+++ b/qtbase/src/gui/image/qbmphandler.cpp
@@ -212,6 +212,9 @@ static bool read_dib_body(QDataStream &s, const BMP_INFOHDR &bi, int offset, int
     int blue_scale = 0;
     int alpha_scale = 0;
 
+	if (!d->isSequential())
+		d->seek(startpos + BMP_FILEHDR_SIZE + (bi.biSize >= BMP_WIN4 ? BMP_WIN : bi.biSize)); // goto start of colormap
+
     if (bi.biSize >= BMP_WIN4 || (comp == BMP_BITFIELDS && (nbits == 16 || nbits == 32))) {
         if (d->read((char *)&red_mask, sizeof(red_mask)) != sizeof(red_mask))
             return false;
@@ -299,9 +302,6 @@ static bool read_dib_body(QDataStream &s, const BMP_INFOHDR &bi, int offset, int
     image.setDotsPerMeterX(bi.biXPelsPerMeter);
     image.setDotsPerMeterY(bi.biYPelsPerMeter);
 
-    if (!d->isSequential())
-        d->seek(startpos + BMP_FILEHDR_SIZE + (bi.biSize >= BMP_WIN4? BMP_WIN : bi.biSize)); // goto start of colormap
-
     if (ncols > 0) {                                // read color table
         uchar rgb[4];
         int   rgb_len = t == BMP_OLD ? 3 : 4;
diff --git a/qtbase/src/gui/kernel/qplatformdialoghelper.h b/qtbase/src/gui/kernel/qplatformdialoghelper.h
index 8b2b988..2d1cdd9 100644
--- a/qtbase/src/gui/kernel/qplatformdialoghelper.h
+++ b/qtbase/src/gui/kernel/qplatformdialoghelper.h
@@ -363,6 +363,7 @@ public:
     virtual QUrl directory() const = 0;
     virtual void selectFile(const QUrl &filename) = 0;
     virtual QList<QUrl> selectedFiles() const = 0;
+	virtual QByteArray selectedRemoteContent() const { return QByteArray(); }
     virtual void setFilter() = 0;
     virtual void selectNameFilter(const QString &filter) = 0;
     virtual QString selectedNameFilter() const = 0;
diff --git a/qtbase/src/gui/painting/qimagescale.cpp b/qtbase/src/gui/painting/qimagescale.cpp
index 9b4eabc..a3e0e04 100644
--- a/qtbase/src/gui/painting/qimagescale.cpp
+++ b/qtbase/src/gui/painting/qimagescale.cpp
@@ -313,7 +313,10 @@ static void qt_qimageScaleAARGBA_up_xy(QImageScaleInfo *isi, unsigned int *dest,
             for (int x = dxx; x < end; x++) {
                 const unsigned int *pix = sptr + xpoints[x];
                 const int xap = xapoints[x];
-                *dptr = INTERPOLATE_PIXEL_256(pix[0], 256 - xap, pix[1], xap);
+				if (xap > 0)
+					*dptr = INTERPOLATE_PIXEL_256(pix[0], 256 - xap, pix[1], xap);
+				else
+					*dptr = pix[0];
                 dptr++;
             }
         }
diff --git a/qtbase/src/gui/painting/qpaintengine_p.h b/qtbase/src/gui/painting/qpaintengine_p.h
index c58662e..468d671 100644
--- a/qtbase/src/gui/painting/qpaintengine_p.h
+++ b/qtbase/src/gui/painting/qpaintengine_p.h
@@ -79,8 +79,18 @@ public:
         if (hasSystemTransform) {
             if (systemTransform.type() <= QTransform::TxTranslate)
                 systemClip.translate(qRound(systemTransform.dx()), qRound(systemTransform.dy()));
-            else
-                systemClip = systemTransform.map(systemClip);
+			else {
+// Transform the system clip region back from device pixels to device-independent pixels before
+// applying systemTransform, which already has transform from device-independent pixels to device pixels
+#ifdef Q_OS_MAC
+				QTransform scaleTransform;
+				const qreal invDevicePixelRatio = 1. / pdev->devicePixelRatio();
+				scaleTransform.scale(invDevicePixelRatio, invDevicePixelRatio);
+				systemClip = systemTransform.map(scaleTransform.map(systemClip));
+#else
+				systemClip = systemTransform.map(systemClip);
+#endif
+			}
         }
 
         // Make sure we're inside the viewport.
diff --git a/qtbase/src/gui/text/qtextlayout.cpp b/qtbase/src/gui/text/qtextlayout.cpp
index 7da3e84..0829250 100644
--- a/qtbase/src/gui/text/qtextlayout.cpp
+++ b/qtbase/src/gui/text/qtextlayout.cpp
@@ -643,6 +643,9 @@ int QTextLayout::nextCursorPosition(int oldPos, CursorMode mode) const
         while (oldPos < len && !attributes[oldPos].graphemeBoundary)
             oldPos++;
     } else {
+		while (oldPos < len && attributes[oldPos].whiteSpace)
+			oldPos++;
+
         if (oldPos < len && d->atWordSeparator(oldPos)) {
             oldPos++;
             while (oldPos < len && d->atWordSeparator(oldPos))
@@ -651,8 +654,6 @@ int QTextLayout::nextCursorPosition(int oldPos, CursorMode mode) const
             while (oldPos < len && !attributes[oldPos].whiteSpace && !d->atWordSeparator(oldPos))
                 oldPos++;
         }
-        while (oldPos < len && attributes[oldPos].whiteSpace)
-            oldPos++;
     }
 
     return oldPos;
diff --git a/qtbase/src/gui/text/qtextlayout.h b/qtbase/src/gui/text/qtextlayout.h
index 47dcd38..64c3810 100644
--- a/qtbase/src/gui/text/qtextlayout.h
+++ b/qtbase/src/gui/text/qtextlayout.h
@@ -186,6 +186,8 @@ private:
                                QRectF *brect, int tabstops, int* tabarray, int tabarraylen,
                                QPainter *painter);
     QTextEngine *d;
+
+	friend class TextBlock;
 };
 
 
diff --git a/qtbase/src/network/socket/qnativesocketengine_win.cpp b/qtbase/src/network/socket/qnativesocketengine_win.cpp
index 72f85c8..a1c2e08 100644
--- a/qtbase/src/network/socket/qnativesocketengine_win.cpp
+++ b/qtbase/src/network/socket/qnativesocketengine_win.cpp
@@ -685,7 +685,13 @@ bool QNativeSocketEnginePrivate::nativeConnect(const QHostAddress &address, quin
                             errorDetected = true;
                             break;
                         }
-                        if (value == WSAEADDRNOTAVAIL) {
+						if (value == WSAENETUNREACH) {
+							setError(QAbstractSocket::NetworkError, NetworkUnreachableErrorString);
+							socketState = QAbstractSocket::UnconnectedState;
+							errorDetected = true;
+							break;
+						}
+						if (value == WSAEADDRNOTAVAIL) {
                             setError(QAbstractSocket::NetworkError, AddressNotAvailableErrorString);
                             socketState = QAbstractSocket::UnconnectedState;
                             errorDetected = true;
diff --git a/qtbase/src/platformsupport/fontdatabases/basic/qbasicfontdatabase.cpp b/qtbase/src/platformsupport/fontdatabases/basic/qbasicfontdatabase.cpp
index 65cdabd..190683e 100644
--- a/qtbase/src/platformsupport/fontdatabases/basic/qbasicfontdatabase.cpp
+++ b/qtbase/src/platformsupport/fontdatabases/basic/qbasicfontdatabase.cpp
@@ -198,6 +198,78 @@ void QBasicFontDatabase::releaseHandle(void *handle)
 
 extern FT_Library qt_getFreetype();
 
+// copied from freetype with some modifications
+
+#ifndef FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY
+#define FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY FT_MAKE_TAG('i', 'g', 'p', 'f')
+#endif
+
+#ifndef FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY
+#define FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY FT_MAKE_TAG('i', 'g', 'p', 's')
+#endif
+
+/* there's a Mac-specific extended implementation of FT_New_Face() */
+/* in src/base/ftmac.c                                             */
+
+#if !defined( FT_MACINTOSH ) || defined( DARWIN_NO_CARBON )
+
+/* documentation is in freetype.h */
+
+FT_Error __ft_New_Face(FT_Library library, const char* pathname, FT_Long face_index, FT_Face *aface) {
+	FT_Open_Args args;
+
+	/* test for valid `library' and `aface' delayed to FT_Open_Face() */
+	if (!pathname)
+		return FT_Err_Invalid_Argument;
+
+	FT_Parameter params[2];
+	params[0].tag = FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY;
+	params[0].data = 0;
+	params[1].tag = FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY;
+	params[1].data = 0;
+	args.flags = FT_OPEN_PATHNAME | FT_OPEN_PARAMS;
+	args.pathname = (char*)pathname;
+	args.stream = NULL;
+	args.num_params = 2;
+	args.params = params;
+
+	return FT_Open_Face(library, &args, face_index, aface);
+}
+
+#else
+
+FT_Error __ft_New_Face(FT_Library library, const char* pathname, FT_Long face_index, FT_Face *aface) {
+	return FT_New_Face(library, pathname, face_index, aface);
+}
+
+#endif  /* defined( FT_MACINTOSH ) && !defined( DARWIN_NO_CARBON ) */
+
+/* documentation is in freetype.h */
+
+FT_Error __ft_New_Memory_Face(FT_Library library, const FT_Byte* file_base, FT_Long file_size, FT_Long face_index, FT_Face *aface) {
+	FT_Open_Args  args;
+
+	/* test for valid `library' and `face' delayed to FT_Open_Face() */
+	if (!file_base)
+		return FT_Err_Invalid_Argument;
+
+	FT_Parameter params[2];
+	params[0].tag = FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY;
+	params[0].data = 0;
+	params[1].tag = FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY;
+	params[1].data = 0;
+	args.flags = FT_OPEN_MEMORY | FT_OPEN_PARAMS;
+	args.memory_base = file_base;
+	args.memory_size = file_size;
+	args.stream = NULL;
+	args.num_params = 2;
+	args.params = params;
+
+	return FT_Open_Face(library, &args, face_index, aface);
+}
+
+// end
+
 QStringList QBasicFontDatabase::addTTFile(const QByteArray &fontData, const QByteArray &file, QSupportedWritingSystems *supportedWritingSystems)
 {
     FT_Library library = qt_getFreetype();
@@ -209,9 +281,9 @@ QStringList QBasicFontDatabase::addTTFile(const QByteArray &fontData, const QByt
         FT_Face face;
         FT_Error error;
         if (!fontData.isEmpty()) {
-            error = FT_New_Memory_Face(library, (const FT_Byte *)fontData.constData(), fontData.size(), index, &face);
+			error = __ft_New_Memory_Face(library, (const FT_Byte *)fontData.constData(), fontData.size(), index, &face);
         } else {
-            error = FT_New_Face(library, file.constData(), index, &face);
+            error = __ft_New_Face(library, file.constData(), index, &face);
         }
         if (error != FT_Err_Ok) {
             qDebug() << "FT_New_Face failed with index" << index << ":" << hex << error;
diff --git a/qtbase/src/platformsupport/fontdatabases/fontconfig/qfontconfigdatabase.cpp b/qtbase/src/platformsupport/fontdatabases/fontconfig/qfontconfigdatabase.cpp
index 112bb8e..9f1df70 100644
--- a/qtbase/src/platformsupport/fontdatabases/fontconfig/qfontconfigdatabase.cpp
+++ b/qtbase/src/platformsupport/fontdatabases/fontconfig/qfontconfigdatabase.cpp
@@ -373,6 +373,15 @@ static void populateFromPattern(FcPattern *pattern)
         return;
 
     familyName = QString::fromUtf8((const char *)value);
+    if (familyName == QLatin1String("Open Sans")) {
+        FcChar8 *styl = 0;
+        if (FcPatternGetString(pattern, FC_STYLE, 0, &styl) == FcResultMatch) {
+            QString style = QString::fromUtf8(reinterpret_cast<const char *>(styl));
+            if (style == QLatin1String("Semibold")) {
+                familyName.append(QChar(QChar::Space)).append(style);
+            }
+        }
+    }
 
     slant_value = FC_SLANT_ROMAN;
     weight_value = FC_WEIGHT_REGULAR;
@@ -781,6 +790,15 @@ QStringList QFontconfigDatabase::addApplicationFont(const QByteArray &fontData,
         FcChar8 *fam = 0;
         if (FcPatternGetString(pattern, FC_FAMILY, 0, &fam) == FcResultMatch) {
             QString family = QString::fromUtf8(reinterpret_cast<const char *>(fam));
+            if (family == QLatin1String("Open Sans")) {
+                FcChar8 *styl = 0;
+                if (FcPatternGetString(pattern, FC_STYLE, 0, &styl) == FcResultMatch) {
+                    QString style = QString::fromUtf8(reinterpret_cast<const char *>(styl));
+                    if (style == QLatin1String("Semibold")) {
+                        family.append(QChar(QChar::Space)).append(style);
+                    }
+                }
+            }
             families << family;
         }
         populateFromPattern(pattern);
diff --git a/qtbase/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase.mm b/qtbase/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase.mm
index be70092..1594dac 100644
--- a/qtbase/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase.mm
+++ b/qtbase/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase.mm
@@ -263,6 +263,10 @@ static void getFontDescription(CTFontDescriptorRef font, FontDescription *fd)
 
     fd->foundryName = QStringLiteral("CoreText");
     fd->familyName = (CFStringRef) CTFontDescriptorCopyAttribute(font, kCTFontFamilyNameAttribute);
+    QCFString _displayName = (CFStringRef) CTFontDescriptorCopyAttribute(font, kCTFontDisplayNameAttribute);
+    if (_displayName == QStringLiteral("Open Sans Semibold")) {
+        fd->familyName = _displayName;
+    }
     fd->styleName = (CFStringRef)CTFontDescriptorCopyAttribute(font, kCTFontStyleNameAttribute);
     fd->weight = QFont::Normal;
     fd->style = QFont::StyleNormal;
diff --git a/qtbase/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.mm b/qtbase/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.mm
index f3a0216..643ebdd 100644
--- a/qtbase/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.mm
+++ b/qtbase/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.mm
@@ -210,7 +210,7 @@ QT_END_NAMESPACE
     if (reflectionDelegate) {
         if ([reflectionDelegate respondsToSelector:@selector(applicationShouldTerminate:)])
             return [reflectionDelegate applicationShouldTerminate:sender];
-        return NSTerminateNow;
+        //return NSTerminateNow;
     }
 
     if ([self canQuit]) {
diff --git a/qtbase/src/plugins/platforms/cocoa/qcocoasystemtrayicon.mm b/qtbase/src/plugins/platforms/cocoa/qcocoasystemtrayicon.mm
index 713758c..9c695aa 100644
--- a/qtbase/src/plugins/platforms/cocoa/qcocoasystemtrayicon.mm
+++ b/qtbase/src/plugins/platforms/cocoa/qcocoasystemtrayicon.mm
@@ -94,6 +94,7 @@ QT_USE_NAMESPACE
     QCocoaSystemTrayIcon *systray;
     NSStatusItem *item;
     QCocoaMenu *menu;
+	bool menuVisible, iconSelected;
     QIcon icon;
     QT_MANGLE_NAMESPACE(QNSImageView) *imageCell;
 }
@@ -197,7 +198,7 @@ void QCocoaSystemTrayIcon::updateIcon(const QIcon &icon)
     // (device independent pixels). The menu height on past and
     // current OS X versions is 22 points. Provide some future-proofing
     // by deriving the icon height from the menu height.
-    const int padding = 4;
+    const int padding = 0;
     const int menuHeight = [[[NSApplication sharedApplication] mainMenu] menuBarHeight];
     const int maxImageHeight = menuHeight - padding;
 
@@ -207,8 +208,9 @@ void QCocoaSystemTrayIcon::updateIcon(const QIcon &icon)
     // devicePixelRatio for the "best" screen on the system.
     qreal devicePixelRatio = qApp->devicePixelRatio();
     const int maxPixmapHeight = maxImageHeight * devicePixelRatio;
+	const QIcon::Mode mode = m_sys->item->iconSelected ? QIcon::Selected : QIcon::Normal;
     QSize selectedSize;
-    Q_FOREACH (const QSize& size, sortByHeight(icon.availableSizes())) {
+    Q_FOREACH (const QSize& size, sortByHeight(icon.availableSizes(mode))) {
         // Select a pixmap based on the height. We want the largest pixmap
         // with a height smaller or equal to maxPixmapHeight. The pixmap
         // may rectangular; assume it has a reasonable size. If there is
@@ -224,9 +226,9 @@ void QCocoaSystemTrayIcon::updateIcon(const QIcon &icon)
 
     // Handle SVG icons, which do not return anything for availableSizes().
     if (!selectedSize.isValid())
-        selectedSize = icon.actualSize(QSize(maxPixmapHeight, maxPixmapHeight));
+        selectedSize = icon.actualSize(QSize(maxPixmapHeight, maxPixmapHeight), mode);
 
-    QPixmap pixmap = icon.pixmap(selectedSize);
+    QPixmap pixmap = icon.pixmap(selectedSize, mode);
 
     // Draw a low-resolution icon if there is not enough pixels for a retina
     // icon. This prevents showing a small icon on retina displays.
@@ -373,6 +375,10 @@ QT_END_NAMESPACE
     Q_UNUSED(notification);
     down = NO;
 
+    parent->iconSelected = false;
+    parent->systray->updateIcon(parent->icon);
+    parent->menuVisible = false;
+
     [self setNeedsDisplay:YES];
 }
 
@@ -381,6 +387,9 @@ QT_END_NAMESPACE
     down = YES;
     int clickCount = [mouseEvent clickCount];
     [self setNeedsDisplay:YES];
+	
+	parent->iconSelected = (clickCount != 2) && parent->menu;
+    parent->systray->updateIcon(parent->icon);
 
     if (clickCount == 2) {
         [self menuTrackingDone:nil];
@@ -398,6 +407,10 @@ QT_END_NAMESPACE
 -(void)mouseUp:(NSEvent *)mouseEvent
 {
     Q_UNUSED(mouseEvent);
+
+    parent->iconSelected = false;
+    parent->systray->updateIcon(parent->icon);
+
     [self menuTrackingDone:nil];
 }
 
@@ -409,6 +422,10 @@ QT_END_NAMESPACE
 -(void)rightMouseUp:(NSEvent *)mouseEvent
 {
     Q_UNUSED(mouseEvent);
+
+    parent->iconSelected = false;
+    parent->systray->updateIcon(parent->icon);
+
     [self menuTrackingDone:nil];
 }
 
@@ -424,7 +441,7 @@ QT_END_NAMESPACE
 }
 
 -(void)drawRect:(NSRect)rect {
-    [[parent item] drawStatusBarBackgroundInRect:rect withHighlight:down];
+	[[parent item] drawStatusBarBackgroundInRect:rect withHighlight:parent->menu ? down : NO];
     [super drawRect:rect];
 }
 @end
@@ -437,6 +454,7 @@ QT_END_NAMESPACE
     if (self) {
         item = [[[NSStatusBar systemStatusBar] statusItemWithLength:NSSquareStatusItemLength] retain];
         menu = 0;
+		menuVisible = false;
         systray = sys;
         imageCell = [[QNSImageView alloc] initWithParent:self];
         [item setView: imageCell];
@@ -481,6 +499,7 @@ QT_END_NAMESPACE
          selector:@selector(menuTrackingDone:)
              name:NSMenuDidEndTrackingNotification
                  object:m];
+		menuVisible = true;
         [item popUpStatusItemMenu: m];
     }
 }
diff --git a/qtbase/src/plugins/platforms/cocoa/qcocoawindow.mm b/qtbase/src/plugins/platforms/cocoa/qcocoawindow.mm
index 92fc66a..d18884a 100644
--- a/qtbase/src/plugins/platforms/cocoa/qcocoawindow.mm
+++ b/qtbase/src/plugins/platforms/cocoa/qcocoawindow.mm
@@ -142,7 +142,7 @@ static bool isMouseEvent(NSEvent *ev)
     if (!self.window.delegate)
         return; // Already detached, pending NSAppKitDefined event
 
-    if (pw && pw->frameStrutEventsEnabled() && isMouseEvent(theEvent)) {
+    if (pw && pw->frameStrutEventsEnabled() && pw->m_synchedWindowState != Qt::WindowMinimized && pw->m_isExposed && isMouseEvent(theEvent)) {
         NSPoint loc = [theEvent locationInWindow];
         NSRect windowFrame = [self.window convertRectFromScreen:[self.window frame]];
         NSRect contentFrame = [[self.window contentView] frame];
@@ -924,6 +924,14 @@ void QCocoaWindow::setWindowFilePath(const QString &filePath)
     [m_nsWindow setRepresentedFilename: fi.exists() ? QCFString::toNSString(filePath) : @""];
 }
 
+qreal _win_devicePixelRatio() {
+  qreal result = 1.0;
+  foreach (QScreen *screen, QGuiApplication::screens()) {
+    result = qMax(result, screen->devicePixelRatio());
+  }
+  return result;
+}
+
 void QCocoaWindow::setWindowIcon(const QIcon &icon)
 {
     QCocoaAutoReleasePool pool;
@@ -939,7 +947,8 @@ void QCocoaWindow::setWindowIcon(const QIcon &icon)
     if (icon.isNull()) {
         [iconButton setImage:nil];
     } else {
-        QPixmap pixmap = icon.pixmap(QSize(22, 22));
+        CGFloat hgt = 16. * _win_devicePixelRatio();
+        QPixmap pixmap = icon.pixmap(QSize(hgt, hgt));
         NSImage *image = static_cast<NSImage *>(qt_mac_create_nsimage(pixmap));
         [iconButton setImage:image];
         [image release];
diff --git a/qtbase/src/plugins/platforms/cocoa/qnsview.mm b/qtbase/src/plugins/platforms/cocoa/qnsview.mm
index d44cdb3..cfc8705 100644
--- a/qtbase/src/plugins/platforms/cocoa/qnsview.mm
+++ b/qtbase/src/plugins/platforms/cocoa/qnsview.mm
@@ -1348,7 +1348,7 @@ static QTabletEvent::TabletDevice wacomTabletDevice(NSEvent *theEvent)
 #if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_8
     if (QSysInfo::QSysInfo::MacintoshVersion >= QSysInfo::MV_10_8) {
         // On 10.8 and above, MayBegin is likely to happen.  We treat it the same as an actual begin.
-        if (phase == NSEventPhaseMayBegin) {
+        if (phase == NSEventPhaseMayBegin || phase == NSEventPhaseBegan) {
             m_scrolling = true;
             ph = Qt::ScrollBegin;
         }
@@ -1489,6 +1489,10 @@ static QTabletEvent::TabletDevice wacomTabletDevice(NSEvent *theEvent)
                 && qtKey == Qt::Key_Period) {
             [self handleKeyEvent:nsevent eventType:int(QEvent::KeyPress)];
             return YES;
+        } else if ([nsevent modifierFlags] & NSControlKeyMask
+		        && (qtKey == Qt::Key_Tab || qtKey == Qt::Key_Backtab)) {
+            [self handleKeyEvent:nsevent eventType:int(QEvent::KeyPress)];
+            return YES;
         }
     }
     return [super performKeyEquivalent:nsevent];
diff --git a/qtbase/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp b/qtbase/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp
index da0ba27..1d42b79 100644
--- a/qtbase/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp
+++ b/qtbase/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp
@@ -713,6 +713,8 @@ public:
     QList<QUrl> selectedFiles() const;
     void setSelectedFiles(const QList<QUrl> &);
     QString selectedFile() const;
+	void setSelectedRemoteContent(const QByteArray &);
+	QByteArray selectedRemoteContent() const;
 
 private:
     class Data : public QSharedData {
@@ -720,6 +722,7 @@ private:
         QUrl directory;
         QString selectedNameFilter;
         QList<QUrl> selectedFiles;
+		QByteArray selectedRemoteContent;
         QMutex mutex;
     };
     QExplicitlySharedDataPointer<Data> m_data;
@@ -773,6 +776,20 @@ inline void QWindowsFileDialogSharedData::setSelectedFiles(const QList<QUrl> &ur
     m_data->selectedFiles = urls;
 }
 
+inline QByteArray QWindowsFileDialogSharedData::selectedRemoteContent() const
+{
+	m_data->mutex.lock();
+	const QByteArray result = m_data->selectedRemoteContent;
+	m_data->mutex.unlock();
+	return result;
+}
+
+inline void QWindowsFileDialogSharedData::setSelectedRemoteContent(const QByteArray &c)
+{
+	QMutexLocker(&m_data->mutex);
+	m_data->selectedRemoteContent = c;
+}
+
 inline void QWindowsFileDialogSharedData::fromOptions(const QSharedPointer<QFileDialogOptions> &o)
 {
     QMutexLocker (&m_data->mutex);
@@ -896,6 +913,7 @@ public:
     // Return the result for tracking in OnFileOk(). Differs from selection for
     // example by appended default suffixes, etc.
     virtual QList<QUrl> dialogResult() const = 0;
+	virtual QByteArray dialogRemoteContent() const { return QByteArray(); }
 
     inline void onFolderChange(IShellItem *);
     inline void onSelectionChange();
@@ -1332,8 +1350,15 @@ void QWindowsNativeFileDialogBase::selectFile(const QString &fileName) const
 {
     // Hack to prevent CLSIDs from being set as file name due to
     // QFileDialogPrivate::initialSelection() being QString-based.
-    if (!isClsid(fileName))
-        m_fileDialog->SetFileName((wchar_t*)fileName.utf16());
+	if (!isClsid(fileName))
+	{
+		QString file = QDir::toNativeSeparators(fileName);
+		int lastBackSlash = file.lastIndexOf(QChar::fromLatin1('\\'));
+		if (lastBackSlash >= 0) {
+			file = file.mid(lastBackSlash + 1);
+		}
+		m_fileDialog->SetFileName((wchar_t*)file.utf16());;
+	}
 }
 
 // Return the index of the selected filter, accounting for QFileDialog
@@ -1403,6 +1428,7 @@ bool QWindowsNativeFileDialogBase::onFileOk()
 {
     // Store selected files as GetResults() returns invalid data after the dialog closes.
     m_data.setSelectedFiles(dialogResult());
+	m_data.setSelectedRemoteContent(dialogRemoteContent());
     return true;
 }
 
@@ -1531,6 +1557,7 @@ public:
         QWindowsNativeFileDialogBase(data) {}
     virtual QList<QUrl> selectedFiles() const;
     virtual QList<QUrl> dialogResult() const;
+	virtual QByteArray dialogRemoteContent() const;
 
 private:
     inline IFileOpenDialog *openFileDialog() const
@@ -1546,6 +1573,54 @@ QList<QUrl> QWindowsNativeOpenFileDialog::dialogResult() const
     return result;
 }
 
+QByteArray QWindowsNativeOpenFileDialog::dialogRemoteContent() const {
+	QByteArray result;
+	IShellItemArray *items = 0;
+	if (FAILED(openFileDialog()->GetResults(&items)) || !items)
+		return result;
+	DWORD itemCount = 0;
+	if (FAILED(items->GetCount(&itemCount)) || !itemCount)
+		return result;
+	for (DWORD i = 0; i < itemCount; ++i) {
+		IShellItem *item = 0;
+		if (SUCCEEDED(items->GetItemAt(i, &item))) {
+			SFGAOF attributes = 0;
+			// Check whether it has a file system representation?
+			if (FAILED(item->GetAttributes(SFGAO_FILESYSTEM, &attributes)) || (attributes & SFGAO_FILESYSTEM)) {
+				LPWSTR name = 0;
+				if (SUCCEEDED(item->GetDisplayName(SIGDN_FILESYSPATH, &name))) {
+					CoTaskMemFree(name);
+					continue;
+				}
+			}
+			if (FAILED(item->GetAttributes(SFGAO_STREAM, &attributes)) || !(attributes & SFGAO_STREAM))
+				continue;
+
+			IBindCtx *bind = 0;
+			if (FAILED(CreateBindCtx(0, &bind)))
+				continue;
+
+			IStream *stream = 0;
+			if (FAILED(item->BindToHandler(bind, BHID_Stream, IID_IStream, reinterpret_cast<void **>(&stream))))
+				continue;
+
+			STATSTG stat = { 0 };
+			if (FAILED(stream->Stat(&stat, STATFLAG_NONAME)) || !stat.cbSize.QuadPart)
+				continue;
+
+			quint64 fullSize = stat.cbSize.QuadPart;
+			result.resize(fullSize);
+			ULONG read = 0;
+			HRESULT r = stream->Read(result.data(), fullSize, &read);
+			if (r == S_FALSE || r == S_OK)
+				return result;
+
+			result.clear();
+		}
+	}
+	return result;
+}
+
 QList<QUrl> QWindowsNativeOpenFileDialog::selectedFiles() const
 {
     QList<QUrl> result;
@@ -1609,6 +1684,7 @@ public:
     virtual QUrl directory() const Q_DECL_OVERRIDE;
     virtual void selectFile(const QUrl &filename) Q_DECL_OVERRIDE;
     virtual QList<QUrl> selectedFiles() const Q_DECL_OVERRIDE;
+	virtual QByteArray selectedRemoteContent() const Q_DECL_OVERRIDE;
     virtual void setFilter() Q_DECL_OVERRIDE;
     virtual void selectNameFilter(const QString &filter) Q_DECL_OVERRIDE;
     virtual QString selectedNameFilter() const Q_DECL_OVERRIDE;
@@ -1702,6 +1778,11 @@ QList<QUrl> QWindowsFileDialogHelper::selectedFiles() const
     return m_data.selectedFiles();
 }
 
+QByteArray QWindowsFileDialogHelper::selectedRemoteContent() const
+{
+	return m_data.selectedRemoteContent();
+}
+
 void QWindowsFileDialogHelper::setFilter()
 {
     qCDebug(lcQpaDialogs) << __FUNCTION__;
@@ -1992,6 +2073,7 @@ public:
     virtual QUrl directory() const Q_DECL_OVERRIDE;
     virtual void selectFile(const QUrl &url) Q_DECL_OVERRIDE;
     virtual QList<QUrl> selectedFiles() const Q_DECL_OVERRIDE;
+	virtual QByteArray selectedRemoteContent() const Q_DECL_OVERRIDE;
     virtual void setFilter() Q_DECL_OVERRIDE {}
     virtual void selectNameFilter(const QString &) Q_DECL_OVERRIDE;
     virtual QString selectedNameFilter() const Q_DECL_OVERRIDE;
@@ -2035,6 +2117,11 @@ QList<QUrl> QWindowsXpFileDialogHelper::selectedFiles() const
     return m_data.selectedFiles();
 }
 
+QByteArray QWindowsXpFileDialogHelper::selectedRemoteContent() const
+{
+	return m_data.selectedRemoteContent();
+}
+
 void QWindowsXpFileDialogHelper::selectNameFilter(const QString &f)
 {
     m_data.setSelectedNameFilter(f); // Dialog cannot be updated at run-time.
diff --git a/qtbase/src/plugins/platforms/windows/qwindowswindow.cpp b/qtbase/src/plugins/platforms/windows/qwindowswindow.cpp
index 543c081..d80429b 100644
--- a/qtbase/src/plugins/platforms/windows/qwindowswindow.cpp
+++ b/qtbase/src/plugins/platforms/windows/qwindowswindow.cpp
@@ -973,7 +973,7 @@ void QWindowsWindow::destroyWindow()
         // Clear any transient child relationships as Windows will otherwise destroy them (QTBUG-35499, QTBUG-36666)
         if (QWindow *transientChild = findTransientChild(window()))
             if (QWindowsWindow *tw = QWindowsWindow::baseWindowOf(transientChild))
-                tw->updateTransientParent();
+				tw->clearTransientParent();
         QWindowsContext *context = QWindowsContext::instance();
         if (context->windowUnderMouse() == window())
             context->clearWindowUnderMouse();
@@ -1178,11 +1178,24 @@ void QWindowsWindow::updateTransientParent() const
         if (const QWindowsWindow *tw = QWindowsWindow::baseWindowOf(tp))
             if (!tw->testFlag(WithinDestroy)) // Prevent destruction by parent window (QTBUG-35499, QTBUG-36666)
                 newTransientParent = tw->handle();
-    if (newTransientParent != oldTransientParent)
+	if (newTransientParent && newTransientParent != oldTransientParent)
         SetWindowLongPtr(m_data.hwnd, GWL_HWNDPARENT, (LONG_PTR)newTransientParent);
 #endif // !Q_OS_WINCE
 }
 
+void QWindowsWindow::clearTransientParent() const
+{
+#ifndef Q_OS_WINCE
+	if (window()->type() == Qt::Popup)
+		return; // QTBUG-34503, // a popup stays on top, no parent, see also WindowCreationData::fromWindow().
+	// Update transient parent.
+	const HWND oldTransientParent = transientParentHwnd(m_data.hwnd);
+	HWND newTransientParent = 0;
+	if (newTransientParent != oldTransientParent)
+		SetWindowLongPtr(m_data.hwnd, GWL_HWNDPARENT, (LONG_PTR)newTransientParent);
+#endif // !Q_OS_WINCE
+}
+
 static inline bool testShowWithoutActivating(const QWindow *window)
 {
     // QWidget-attribute Qt::WA_ShowWithoutActivating .
diff --git a/qtbase/src/plugins/platforms/windows/qwindowswindow.h b/qtbase/src/plugins/platforms/windows/qwindowswindow.h
index fff90b4..71d060b 100644
--- a/qtbase/src/plugins/platforms/windows/qwindowswindow.h
+++ b/qtbase/src/plugins/platforms/windows/qwindowswindow.h
@@ -273,6 +273,7 @@ private:
     inline void setWindowState_sys(Qt::WindowState newState);
     inline void setParent_sys(const QPlatformWindow *parent);
     inline void updateTransientParent() const;
+	inline void clearTransientParent() const;
     void destroyWindow();
     inline bool isDropSiteEnabled() const { return m_dropTarget != 0; }
     void setDropSiteEnabled(bool enabled);
diff --git a/qtbase/src/widgets/dialogs/qfiledialog.cpp b/qtbase/src/widgets/dialogs/qfiledialog.cpp
index a9d5574..ea8aa43 100644
--- a/qtbase/src/widgets/dialogs/qfiledialog.cpp
+++ b/qtbase/src/widgets/dialogs/qfiledialog.cpp
@@ -1199,6 +1199,14 @@ QList<QUrl> QFileDialogPrivate::userSelectedFiles() const
     return files;
 }
 
+QByteArray QFileDialogPrivate::userSelectedRemoteContent() const
+{
+	if (nativeDialogInUse)
+		return selectedRemoteContent_sys();
+
+	return QByteArray();
+}
+
 QStringList QFileDialogPrivate::addDefaultSuffixToFiles(const QStringList &filesToFix) const
 {
     QStringList files;
@@ -1262,6 +1270,13 @@ QStringList QFileDialog::selectedFiles() const
     return files;
 }
 
+QByteArray QFileDialog::selectedRemoteContent() const
+{
+	Q_D(const QFileDialog);
+
+	return d->userSelectedRemoteContent();
+}
+
 /*!
     Returns a list of urls containing the selected files in the dialog.
     If no files are selected, or the mode is not ExistingFiles or
diff --git a/qtbase/src/widgets/dialogs/qfiledialog.h b/qtbase/src/widgets/dialogs/qfiledialog.h
index 95209bc..0dca0ef 100644
--- a/qtbase/src/widgets/dialogs/qfiledialog.h
+++ b/qtbase/src/widgets/dialogs/qfiledialog.h
@@ -106,6 +106,7 @@ public:
 
     void selectFile(const QString &filename);
     QStringList selectedFiles() const;
+	QByteArray selectedRemoteContent() const;
 
     void selectUrl(const QUrl &url);
     QList<QUrl> selectedUrls() const;
diff --git a/qtbase/src/widgets/dialogs/qfiledialog_p.h b/qtbase/src/widgets/dialogs/qfiledialog_p.h
index f610e46..16fa44e 100644
--- a/qtbase/src/widgets/dialogs/qfiledialog_p.h
+++ b/qtbase/src/widgets/dialogs/qfiledialog_p.h
@@ -123,6 +123,7 @@ public:
     static QString initialSelection(const QUrl &path);
     QStringList typedFiles() const;
     QList<QUrl> userSelectedFiles() const;
+	QByteArray userSelectedRemoteContent() const;
     QStringList addDefaultSuffixToFiles(const QStringList &filesToFix) const;
     QList<QUrl> addDefaultSuffixToUrls(const QList<QUrl> &urlsToFix) const;
     bool removeDirectory(const QString &path);
@@ -256,6 +257,7 @@ public:
     QUrl directory_sys() const;
     void selectFile_sys(const QUrl &filename);
     QList<QUrl> selectedFiles_sys() const;
+	QByteArray selectedRemoteContent_sys() const;
     void setFilter_sys();
     void selectNameFilter_sys(const QString &filter);
     QString selectedNameFilter_sys() const;
@@ -393,6 +395,13 @@ inline QList<QUrl> QFileDialogPrivate::selectedFiles_sys() const
     return QList<QUrl>();
 }
 
+inline QByteArray QFileDialogPrivate::selectedRemoteContent_sys() const
+{
+	if (QPlatformFileDialogHelper *helper = platformFileDialogHelper())
+		return helper->selectedRemoteContent();
+	return QByteArray();
+}
+
 inline void QFileDialogPrivate::setFilter_sys()
 {
     if (QPlatformFileDialogHelper *helper = platformFileDialogHelper())
diff --git a/qtbase/src/widgets/kernel/qwidget.cpp b/qtbase/src/widgets/kernel/qwidget.cpp
index e701eb0..1bdaff5 100644
--- a/qtbase/src/widgets/kernel/qwidget.cpp
+++ b/qtbase/src/widgets/kernel/qwidget.cpp
@@ -8683,7 +8683,7 @@ bool QWidget::event(QEvent *event)
     case QEvent::KeyPress: {
         QKeyEvent *k = (QKeyEvent *)event;
         bool res = false;
-        if (!(k->modifiers() & (Qt::ControlModifier | Qt::AltModifier))) {  //### Add MetaModifier?
+		if (!(k->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier))) {  //### Add MetaModifier?
             if (k->key() == Qt::Key_Backtab
                 || (k->key() == Qt::Key_Tab && (k->modifiers() & Qt::ShiftModifier)))
                 res = focusNextPrevChild(false);
diff --git a/qtbase/src/widgets/util/qsystemtrayicon.cpp b/qtbase/src/widgets/util/qsystemtrayicon.cpp
index dc2737c..aa9bc91 100644
--- a/qtbase/src/widgets/util/qsystemtrayicon.cpp
+++ b/qtbase/src/widgets/util/qsystemtrayicon.cpp
@@ -711,6 +711,8 @@ void QSystemTrayIconPrivate::updateMenu_sys_qpa()
     if (menu) {
         addPlatformMenu(menu);
         qpa_sys->updateMenu(menu->platformMenu());
+	} else {
+		qpa_sys->updateMenu(0);
     }
 }
 
diff --git a/qtbase/src/widgets/widgets/qwidgetlinecontrol.cpp b/qtbase/src/widgets/widgets/qwidgetlinecontrol.cpp
index 759e41a..fbd3064 100644
--- a/qtbase/src/widgets/widgets/qwidgetlinecontrol.cpp
+++ b/qtbase/src/widgets/widgets/qwidgetlinecontrol.cpp
@@ -1884,7 +1884,7 @@ void QWidgetLineControl::processKeyEvent(QKeyEvent* event)
         && event->modifiers() != Qt::ControlModifier
         && event->modifiers() != (Qt::ControlModifier | Qt::ShiftModifier)) {
         QString t = event->text();
-        if (!t.isEmpty() && t.at(0).isPrint()) {
+		if (!t.isEmpty() && (t.at(0).isPrint() || t.at(0).unicode() == 0x200C || t.at(0).unicode() == 0x200D)) {
             insert(t);
 #ifndef QT_NO_COMPLETER
             complete(event->key());
diff --git a/qtbase/src/widgets/widgets/qwidgettextcontrol.cpp b/qtbase/src/widgets/widgets/qwidgettextcontrol.cpp
index faa63cb..f3de539 100644
--- a/qtbase/src/widgets/widgets/qwidgettextcontrol.cpp
+++ b/qtbase/src/widgets/widgets/qwidgettextcontrol.cpp
@@ -1348,7 +1348,7 @@ process:
             return;
         }
         QString text = e->text();
-        if (!text.isEmpty() && (text.at(0).isPrint() || text.at(0) == QLatin1Char('\t'))) {
+		if (!text.isEmpty() && (text.at(0).isPrint() || text.at(0) == QLatin1Char('\t') || text.at(0).unicode() == 0x200C || text.at(0).unicode() == 0x200D)) {
             if (overwriteMode
                 // no need to call deleteChar() if we have a selection, insertText
                 // does it already
